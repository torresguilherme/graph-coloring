#ifndef TABUCOL_H_
#define TABUCOL_H_
#include "graph.h"
#include "dsatur.h"

/*
	Returns the chromatic number of the best solution found with tabucol.
	Also sets the values of the taboo duration and maximum number of iterations to v (number of vertexes) and 5*v respectively
*/
int TabucolChroma(Graph *g);

/*
	Performs the Tabucol heuristic. It uses an initial solution generated by dsatur and attempts to lower the chromatic number,
	setting the highest colored vertexes to random and then performming the taboo search using the generated parameters for each
	instance. It stops after performing 5*v iterations and not finding a legal solution, assuming this is the best you can hope for.
*/
int *Tabucol(Graph *g, int num_vertex, int max_iterations, int taboo_duration);

int DeltaFunction(int **gamma, int vertex, int current_color, int next_color);
/*
	delta(v, i) = (conflicts if color(v) = i) - (current conflicts in v)
	Generates a v x c matrix with the delta values for each (v, i) move (v is a vertex and i is a color). This matrix reduces drastically
	the complexity of the execution, since a naive implementation of Tabucol would calculate the delta values for each move after each
	iteration and a major part of the execution time would be spent on this operation.
*/
void CalculateGammasForAVertex(Graph *g, int *colors, int **gamma, int v);

/*
	Finds the best possible move for an iteration, picking up the highest delta value from the matrix in O(n²).
	(which is not currently taboo)
*/
pair<int, int> LookForBestMove(int **gamma, int *colors, int **taboo_list, int num_vertex, int num_colors);

/*
	Updates the delta matrix. This has to be done after each iteration of tabucol. For a (v, i) move, all the values in the v-line must
	be updated and also the value of each one of it's neighbours. In case v starts a conflict with one of it's neighbours, this
	neighbour's delta values in the matrix also need to be updated.
*/
void UpdateGammas(Graph *g, int **gamma, int *colors, pair<int, int> nextMove);

/*
	Adds a recently performed move to the taboo list for a given duration. The taboo list is a matrix where all the non-taboo values are
	zero, and the forbidden ones are the number of iterations left for their aspiration criterium.
*/
void AddToTabooList(int **list, pair<int, int> move, int duration);

/*
	Finds out if a move is taboo or not in O(1).
*/
int IsTaboo(int **list, pair<int, int> move);

/*
	Updates the taboo list in O(n²). All the non-zero values are decremented by 1.
*/
void UpdateTabooList(int **list, int num_vertex, int color_number);

#endif
